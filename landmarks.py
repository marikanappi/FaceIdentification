# -*- coding: utf-8 -*-
"""Landmarks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11O9UNLpuOlMdpCFqJyxwyGUGAG7vQg3l
"""

!pip install mediapipe

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Carica immagine RGB e depth map
image = cv2.imread("image.png")  # immagine a colori
depth_map = cv2.imread("depth.png", cv2.IMREAD_UNCHANGED)  # profondit√† per pixel

# Mostra immagini (opzionale)
cv2_imshow(image)
cv2_imshow(depth_map if len(depth_map.shape) == 2 else cv2.cvtColor(depth_map, cv2.COLOR_BGR2GRAY))

!pip install --force-reinstall mediapipe

import mediapipe as mp

# Converti in RGB per MediaPipe
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Inizializza Face Mesh
mp_face = mp.solutions.face_mesh
face_mesh = mp_face.FaceMesh(static_image_mode=True, max_num_faces=1, refine_landmarks=True)

# Rilevamento
results = face_mesh.process(image_rgb)

# Landmark che ci servono
landmark_ids = {
    'ensx': 133,
    'exsx': 33,
    'se': 234,
    'prn': 1,
    'alsx': 98,
    'sn': 2
}

landmarks_3d = {}

if results.multi_face_landmarks:
    for face_landmarks in results.multi_face_landmarks:
        for name, idx in landmark_ids.items():
            lm = face_landmarks.landmark[idx]
            x = int(lm.x * image.shape[1])
            y = int(lm.y * image.shape[0])
            z = int(depth_map[y, x]) if y < depth_map.shape[0] and x < depth_map.shape[1] else 0
            landmarks_3d[name] = (x, y, z)
            print(f"{name}: (x={x}, y={y}, z={z})")
else:
    print("Nessun volto rilevato.")

# Funzione per distanza euclidea 3D
def dist(p1, p2):
    return np.linalg.norm(np.array(p1) - np.array(p2))

# Calcola e stampa distanze
print("\nüìê Distanze Euclidee 3D:")
pairs = [
    ("ensx", "se"),
    ("ensx", "exsx"),
    ("se", "prn"),
    ("se", "alsx"),
    ("prn", "alsx"),
    ("ensx", "alsx"),
    ("prn", "sn"),
    ("alsx", "sn"),
    ("ensx", "prn")
]

for a, b in pairs:
    if a in landmarks_3d and b in landmarks_3d:
        d = dist(landmarks_3d[a], landmarks_3d[b])
        print(f"{a}-{b}: {d:.2f}")
    else:
        print(f"{a}-{b}: dati mancanti")

# Disegna i landmark sull'immagine
img_copy = image.copy()
for name, (x, y, _) in landmarks_3d.items():
    cv2.circle(img_copy, (x, y), 4, (0, 255, 0), -1)
    cv2.putText(img_copy, name, (x+5, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,255,0), 1)

cv2_imshow(img_copy)